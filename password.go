package password

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"math"
	"runtime"

	"gitlab.com/zephinzer/akounts/lib/errors"
	"golang.org/x/crypto/argon2"
)

// VariableArgon2RequiredMemory defines the recommended memory in bytes
// to use to generate an Argon2id hashed password
const VariableArgon2RequiredMemory uint64 = 64 * 1024

// VariableMemoryTolerance defines the maximum amount of the available heap
// to use for hashing passwords
const VariableMemoryTolerance float64 = 0.5

// Hash hashes and salts the given plaintext string and returns
// the result as a base64-encoded hash and salt
func Hash(plaintext string) (string, string, error) {
	generatedSalt, err := generateRandomBytes(32)
	if err != nil {
		return "", "", err
	}
	generatedHash := generateArgon2idHash(plaintext, generatedSalt)
	encodedHash := base64.RawStdEncoding.EncodeToString(generatedHash)
	encodedSalt := base64.RawStdEncoding.EncodeToString(generatedSalt)
	return encodedHash, encodedSalt, nil
}

// Verify verifies a provided plaintext string matches the
// provided base64-encoded hash and salt
func Verify(plaintext string, encodedHash string, encodedSalt string) error {
	hash, err := base64.RawStdEncoding.DecodeString(encodedHash)
	if err != nil {
		return errors.New("AUTH_HASH_DECODE", "error while decoding hash: %s", err.Error())
	}
	salt, err := base64.RawStdEncoding.DecodeString(encodedSalt)
	if err != nil {
		return errors.New("AUTH_HASH_DECODE", "error while decoding salt: %s", err.Error())
	}
	generatedHash := generateArgon2idHash(plaintext, salt)
	if bytes.Compare(generatedHash, hash) != 0 {
		return errors.New("AUTH_PASSWORD_HASH_WRONG", "provided plaintext string did not match provided hash and salt")
	}
	return nil
}

// generateArgon2idHash returns the hash of the plaintext string
// using Argon2
func generateArgon2idHash(plaintext string, salt []byte) []byte {
	var memoryStatistics runtime.MemStats
	runtime.ReadMemStats(&memoryStatistics)
	availableMemoryInBytes := memoryStatistics.Alloc
	recommendedMemoryInBytes := VariableArgon2RequiredMemory
	numberOfIterations := uint32(1)
	numberOfBytesToUse := uint32(recommendedMemoryInBytes)
	if recommendedMemoryInBytes > availableMemoryInBytes {
		numberOfIterations = uint32(float64(math.Ceil(float64(recommendedMemoryInBytes)/float64(availableMemoryInBytes))) / VariableMemoryTolerance)
		numberOfBytesToUse = uint32(float64(availableMemoryInBytes) * VariableMemoryTolerance)
	}
	numberOfAvailableThreads := uint8(runtime.GOMAXPROCS(runtime.NumCPU()))
	keyLengthForAES := uint32(32)
	generatedHash := argon2.IDKey(
		[]byte(plaintext),
		salt,
		numberOfIterations,
		numberOfBytesToUse,
		numberOfAvailableThreads,
		keyLengthForAES,
	)
	return generatedHash
}

// generateRandomBytes returns a slice of randomly generated bytes
func generateRandomBytes(requiredLength uint64) ([]byte, error) {
	bytes := make([]byte, requiredLength)
	processedLength, err := rand.Read(bytes)
	if err != nil {
		return nil, err
	}
	if uint64(processedLength) != requiredLength {
		return nil, errors.New("AUTH_GENERATE_BYTES_FAILED", "required length of random bytes (%v) was different from the number of bytes processed (%v)", requiredLength, processedLength)
	}
	return bytes, nil
}
